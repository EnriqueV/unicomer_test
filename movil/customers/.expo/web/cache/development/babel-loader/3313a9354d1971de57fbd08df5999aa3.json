{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"mask\", \"value\", \"onChangeText\", \"placeholderFillCharacter\", \"obfuscationCharacter\", \"showObfuscatedValue\", \"selection\"];\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport * as React from 'react';\nimport TextInput from \"react-native-web/dist/exports/TextInput\";\nimport formatWithMask from \"./formatWithMask\";\nexport default React.forwardRef(function (props, ref) {\n  var mask = props.mask,\n      value = props.value,\n      onChangeText = props.onChangeText,\n      _props$placeholderFil = props.placeholderFillCharacter,\n      placeholderFillCharacter = _props$placeholderFil === void 0 ? '_' : _props$placeholderFil,\n      obfuscationCharacter = props.obfuscationCharacter,\n      showObfuscatedValue = props.showObfuscatedValue,\n      selection = props.selection,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var maskArray = React.useMemo(function () {\n    return typeof mask === 'function' ? mask(value) : mask;\n  }, [mask, value]);\n  var formattedValueResult = React.useMemo(function () {\n    return formatWithMask({\n      text: value || '',\n      mask: mask,\n      obfuscationCharacter: obfuscationCharacter\n    });\n  }, [mask, obfuscationCharacter, value]);\n  var maskHasObfuscation = React.useMemo(function () {\n    return maskArray && !!maskArray.find(function (maskItem) {\n      return Array.isArray(maskItem);\n    });\n  }, [maskArray]);\n  var isValueObfuscated = React.useMemo(function () {\n    return !!maskHasObfuscation && !!showObfuscatedValue;\n  }, [maskHasObfuscation, showObfuscatedValue]);\n  var handleChangeText = React.useCallback(function (text) {\n    var textToFormat = text;\n\n    if (isValueObfuscated) {\n      textToFormat = formattedValueResult.masked || '';\n\n      if (textToFormat.length > text.length) {\n        textToFormat = textToFormat.slice(0, -1);\n      } else if (textToFormat.length < text.length) {\n        textToFormat = textToFormat + text[text.length - 1];\n      }\n    }\n\n    var result = formatWithMask({\n      text: textToFormat,\n      mask: mask,\n      obfuscationCharacter: obfuscationCharacter\n    });\n    onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n  }, [isValueObfuscated, mask, obfuscationCharacter, onChangeText, formattedValueResult.masked]);\n  var defaultPlaceholder = React.useMemo(function () {\n    if (maskArray) {\n      return maskArray.map(function (maskChar) {\n        if (typeof maskChar === 'string') {\n          return maskChar;\n        } else {\n          return placeholderFillCharacter;\n        }\n      }).join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n  var inputValue = isValueObfuscated ? formattedValueResult.obfuscated : formattedValueResult.masked;\n  return React.createElement(TextInput, _extends({\n    placeholder: defaultPlaceholder\n  }, rest, {\n    value: inputValue,\n    selection: isValueObfuscated ? {\n      start: inputValue.length,\n      end: inputValue.length\n    } : selection,\n    onChangeText: handleChangeText,\n    ref: ref\n  }));\n});","map":{"version":3,"sources":["MaskInput.tsx"],"names":["placeholderFillCharacter","rest","maskArray","React","mask","formattedValueResult","formatWithMask","text","value","obfuscationCharacter","maskHasObfuscation","maskItem","Array","isValueObfuscated","handleChangeText","textToFormat","result","onChangeText","defaultPlaceholder","maskChar","inputValue","start","end","length","ref"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { TextInput } from 'react-native';\n\nimport type { MaskInputProps } from './MaskInput.types';\nimport formatWithMask from './formatWithMask';\n\nexport default React.forwardRef(function (\n  props: MaskInputProps,\n  ref: React.Ref<TextInput>\n) {\n  const {\n    mask,\n    value,\n    onChangeText,\n    placeholderFillCharacter = '_',\n    obfuscationCharacter,\n    showObfuscatedValue,\n    selection,\n    ...rest\n  } = props;\n\n  const maskArray = React.useMemo(\n    () => (typeof mask === 'function' ? mask(value) : mask),\n    [mask, value]\n  );\n\n  const formattedValueResult = React.useMemo(() => {\n    return formatWithMask({ text: value || '', mask, obfuscationCharacter });\n  }, [mask, obfuscationCharacter, value]);\n\n  const maskHasObfuscation = React.useMemo(\n    () => maskArray && !!maskArray.find((maskItem) => Array.isArray(maskItem)),\n    [maskArray]\n  );\n\n  const isValueObfuscated = React.useMemo(\n    () => !!maskHasObfuscation && !!showObfuscatedValue,\n    [maskHasObfuscation, showObfuscatedValue]\n  );\n\n  const handleChangeText = React.useCallback(\n    (text: string) => {\n      let textToFormat = text;\n\n      if (isValueObfuscated) {\n        textToFormat = formattedValueResult.masked || '';\n\n        if (textToFormat.length > text.length) {\n          textToFormat = textToFormat.slice(0, -1);\n        } else if (textToFormat.length < text.length) {\n          textToFormat = textToFormat + text[text.length - 1];\n        }\n      }\n\n      const result = formatWithMask({ text: textToFormat, mask, obfuscationCharacter });\n\n      onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n    },\n    [\n      isValueObfuscated,\n      mask,\n      obfuscationCharacter,\n      onChangeText,\n      formattedValueResult.masked,\n    ]\n  );\n\n  const defaultPlaceholder = React.useMemo(() => {\n    if (maskArray) {\n      return maskArray\n        .map((maskChar) => {\n          if (typeof maskChar === 'string') {\n            return maskChar;\n          } else {\n            return placeholderFillCharacter;\n          }\n        })\n        .join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n\n  const inputValue = isValueObfuscated\n    ? formattedValueResult.obfuscated\n    : formattedValueResult.masked;\n\n  return (\n    <TextInput\n      placeholder={defaultPlaceholder}\n      {...rest}\n      value={inputValue}\n      selection={\n        isValueObfuscated\n          ? { start: inputValue.length, end: inputValue.length }\n          : selection\n      }\n      onChangeText={handleChangeText}\n      ref={ref}\n    />\n  );\n});\n"]},"metadata":{},"sourceType":"module"}