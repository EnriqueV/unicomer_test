{"ast":null,"code":"export default function formatWithMask(props) {\n  var text = props.text,\n      mask = props.mask,\n      _props$obfuscationCha = props.obfuscationCharacter,\n      obfuscationCharacter = _props$obfuscationCha === void 0 ? '*' : _props$obfuscationCha;\n  if (!text) return {\n    masked: '',\n    unmasked: '',\n    obfuscated: ''\n  };\n  if (!mask) return {\n    masked: text || '',\n    unmasked: text || '',\n    obfuscated: text || ''\n  };\n  var maskArray = typeof mask === 'function' ? mask(text) : mask;\n  var masked = '';\n  var obfuscated = '';\n  var unmasked = '';\n  var maskCharIndex = 0;\n  var valueCharIndex = 0;\n\n  while (true) {\n    if (maskCharIndex === maskArray.length) {\n      break;\n    }\n\n    if (valueCharIndex === text.length) {\n      break;\n    }\n\n    var maskChar = maskArray[maskCharIndex];\n    var valueChar = text[valueCharIndex];\n\n    if (maskChar === valueChar) {\n      masked += maskChar;\n      obfuscated += maskChar;\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n\n    var unmaskedValueChar = text[valueCharIndex];\n\n    if (typeof maskChar === 'object') {\n      valueCharIndex += 1;\n      var shouldObsfucateChar = Array.isArray(maskChar);\n      var maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n      var matchRegex = RegExp(maskCharRegex).test(valueChar);\n\n      if (matchRegex) {\n        masked += valueChar;\n        obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n        unmasked += unmaskedValueChar;\n        maskCharIndex += 1;\n      }\n\n      continue;\n    } else {\n      masked += maskChar;\n      obfuscated += maskChar;\n      maskCharIndex += 1;\n      continue;\n    }\n  }\n\n  return {\n    masked: masked,\n    unmasked: unmasked,\n    obfuscated: obfuscated\n  };\n}","map":{"version":3,"sources":["formatWithMask.ts"],"names":["obfuscationCharacter","masked","unmasked","obfuscated","text","maskArray","mask","maskCharIndex","valueCharIndex","maskChar","valueChar","unmaskedValueChar","shouldObsfucateChar","Array","maskCharRegex","matchRegex","RegExp"],"mappings":"AAEA,eAAe,SAAA,cAAA,CAAA,KAAA,EAES;EACtB,IAAM,IAAN,GADsB,KACtB,CAAM,IAAN;EAAA,IAAM,IAAN,GADsB,KACtB,CAAM,IAAN;EAAA,4BADsB,KACtB,CAAoBA,oBAApB;EAAA,IAAoBA,oBAApB,sCAA2C,GAA3C;EAGA,IAAI,CAAJ,IAAA,EAAW,OAAO;IAAEC,MAAM,EAAR,EAAA;IAAcC,QAAQ,EAAtB,EAAA;IAA4BC,UAAU,EAAE;EAAxC,CAAP;EACX,IAAI,CAAJ,IAAA,EACE,OAAO;IACLF,MAAM,EAAEG,IAAI,IADP,EAAA;IAELF,QAAQ,EAAEE,IAAI,IAFT,EAAA;IAGLD,UAAU,EAAEC,IAAI,IAAI;EAHf,CAAP;EAMF,IAAIC,SAAS,GAAG,OAAA,IAAA,KAAA,UAAA,GAA6BC,IAAI,CAAjC,IAAiC,CAAjC,GAAhB,IAAA;EAEA,IAAIL,MAAM,GAAV,EAAA;EACA,IAAIE,UAAU,GAAd,EAAA;EACA,IAAID,QAAQ,GAAZ,EAAA;EAEA,IAAIK,aAAa,GAAjB,CAAA;EACA,IAAIC,cAAc,GAAlB,CAAA;;EAEA,OAAA,IAAA,EAAa;IAEX,IAAID,aAAa,KAAKF,SAAS,CAA/B,MAAA,EAAwC;MACtC;IAHS;;IAOX,IAAIG,cAAc,KAAKJ,IAAI,CAA3B,MAAA,EAAoC;MAClC;IACD;;IAED,IAAIK,QAAQ,GAAGJ,SAAS,CAAxB,aAAwB,CAAxB;IACA,IAAIK,SAAS,GAAGN,IAAI,CAZT,cAYS,CAApB;;IAGA,IAAIK,QAAQ,KAAZ,SAAA,EAA4B;MAC1BR,MAAM,IAANA,QAAAA;MACAE,UAAU,IAAVA,QAAAA;MAEAK,cAAc,IAAdA,CAAAA;MACAD,aAAa,IAAbA,CAAAA;MACA;IACD;;IAED,IAAII,iBAAiB,GAAGP,IAAI,CAxBjB,cAwBiB,CAA5B;;IAGA,IAAI,OAAA,QAAA,KAAJ,QAAA,EAAkC;MAEhCI,cAAc,IAAdA,CAAAA;MAEA,IAAMI,mBAAmB,GAAGC,KAAK,CAALA,OAAAA,CAA5B,QAA4BA,CAA5B;MAEA,IAAMC,aAAa,GAAGD,KAAK,CAALA,OAAAA,CAAAA,QAAAA,IAA0BJ,QAAQ,CAAlCI,CAAkC,CAAlCA,GAAtB,QAAA;MAEA,IAAME,UAAU,GAAGC,MAAM,CAANA,aAAM,CAANA,CAAAA,IAAAA,CARa,SAQbA,CAAnB;;MAGA,IAAA,UAAA,EAAgB;QACdf,MAAM,IAANA,SAAAA;QACAE,UAAU,IAAIS,mBAAmB,GAAA,oBAAA,GAAjCT,SAAAA;QACAD,QAAQ,IAARA,iBAAAA;QAEAK,aAAa,IAAbA,CAAAA;MACD;;MAED;IAnBF,CAAA,MAoBO;MAELN,MAAM,IAANA,QAAAA;MACAE,UAAU,IAAVA,QAAAA;MAEAI,aAAa,IAAbA,CAAAA;MACA;IACD;EACF;;EAED,OAAO;IAAEN,MAAF,EAAEA,MAAF;IAAUC,QAAV,EAAUA,QAAV;IAAoBC,UAAAA,EAAAA;EAApB,CAAP;AACD","sourcesContent":["import type { FormatWithMaskProps, FormatWithMaskResult } from './formatWithMask.types';\n\nexport default function formatWithMask(\n  props: FormatWithMaskProps\n): FormatWithMaskResult {\n  const { text, mask, obfuscationCharacter = '*' } = props;\n\n  // make sure it'll not break with null or undefined inputs\n  if (!text) return { masked: '', unmasked: '', obfuscated: '' };\n  if (!mask)\n    return {\n      masked: text || '',\n      unmasked: text || '',\n      obfuscated: text || '',\n    };\n\n  let maskArray = typeof mask === 'function' ? mask(text) : mask;\n\n  let masked = '';\n  let obfuscated = '';\n  let unmasked = '';\n\n  let maskCharIndex = 0;\n  let valueCharIndex = 0;\n\n  while (true) {\n    // if mask is ended, break.\n    if (maskCharIndex === maskArray.length) {\n      break;\n    }\n\n    // if value is ended, break.\n    if (valueCharIndex === text.length) {\n      break;\n    }\n\n    let maskChar = maskArray[maskCharIndex];\n    let valueChar = text[valueCharIndex];\n\n    // value equals mask: add to masked result and advance on both mask and value indexes\n    if (maskChar === valueChar) {\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n\n    let unmaskedValueChar = text[valueCharIndex];\n\n    // it's a regex maskChar: let's advance on value index and validate the value within the regex\n    if (typeof maskChar === 'object') {\n      // advance on value index\n      valueCharIndex += 1;\n\n      const shouldObsfucateChar = Array.isArray(maskChar);\n\n      const maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n\n      const matchRegex = RegExp(maskCharRegex).test(valueChar);\n\n      // value match regex: add to masked and unmasked result and advance on mask index too\n      if (matchRegex) {\n        masked += valueChar;\n        obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n        unmasked += unmaskedValueChar;\n\n        maskCharIndex += 1;\n      }\n\n      continue;\n    } else {\n      // it's a fixed maskChar: add to maskedResult and advance on mask index\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      maskCharIndex += 1;\n      continue;\n    }\n  }\n\n  return { masked, unmasked, obfuscated };\n}\n"]},"metadata":{},"sourceType":"module"}